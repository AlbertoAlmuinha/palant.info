{"title": "BBN challenge resolutions: \"A properly secured parameter\" and \"Exploiting a static page\"", "date": "2018-11-28 02:07:36", "description": "I am explaining my BugBountyNotes challenges \"A properly secured parameter\" and \"Exploiting a static page.\"", "categories": ["security", "challenge"], "slug": "bbn-challenge-resolutions-a-properly-secured-parameter-and-exploiting-a-static-page"}

<p><a href="https://www.bugbountynotes.com/">BugBountyNotes</a> is quickly becoming a great resource for security researches. Their challenges in particular are a fun way of learning ways to exploit vulnerable code. So a month ago I decided to contribute and created two challenges: <a href="https://www.bugbountynotes.com/challenge?id=10">A properly secured parameter</a> (easy) and <a href="https://www.bugbountynotes.com/challenge?id=8">Exploiting a static page</a> (medium). Unlike most other challenges, these don&#8217;t really have any hidden parts. Pretty much everything going on there is visible, yet exploiting the vulnerabilities still requires some thinking. So if you haven&#8217;t looked at these challenges, feel free to stop reading at this point and go try it out. You won&#8217;t be able to submit your answer any more, but as both are about exploiting <span class="caps">XSS</span> vulnerabilities you will know yourself when you are there. Of course, you can also participate in any of the <a href="https://www.bugbountynotes.com/training">ongoing challenges</a> as well.</p>

<p>Still here? Ok, I&#8217;m going to explain these challenges then.</p>

<h4>What&#8217;s up with that parameter?</h4>

<p>We&#8217;ll start with the <a href="https://www.bugbountynotes.com/challenge?id=10">easier challenge</a> first, dedicated to all the custom <span class="caps">URL</span> parsers that developers seem to be very fond of for some reason. The client-side code makes it very obvious that the “message” parameter is vulnerable. With the parameter value being passed to <code>innerHTML</code>, we would want to pass something like <code>&lt;img src=dummy onerror=alert(&quot;xss&quot;)&gt;</code> here (note that <code>innerHTML</code> won&#8217;t execute <code>&lt;script&gt;</code> tags).</p>

<p>But there is a catch of course. Supposedly, the owners of that page discovered the issue. But instead of putting resources into fixing it, they preferred a quick band-aid and configured a <a href="https://en.wikipedia.org/wiki/Web_application_firewall">Web Application Firewall</a> to stop attacks. That&#8217;s the <span class="caps">PHP</span> code emulating the firewall here:</p>

<pre><code> if (preg_match(&#39;/[^\\w\\s-.,&amp;=]/&#39;, urldecode($_SERVER[&#39;QUERY_STRING&#39;])))
    exit(&quot;Invalid parameter value&quot;);</code></pre>

<p>The allowed character set here is the bare minimum to allow the “functionality” to work, and I feel really sorry for anybody who tried to solve the challenge by attacking this “firewall.” The only way around this filter is to avoid going through it in the first place.</p>

<p>It might not be immediately obvious but the <span class="caps">URL</span> parser used by the challenge is flawed:</p>

<pre><code>      function getParam(name)
      {
        var query = location.href.split(&quot;?&quot;)[1];
        if (!query)
          return null;

        var params = query.split(&quot;&amp;&quot;);
        for (var i = 0; i &lt; params.length; i++)
        {
          var parts = params[i].split(&quot;=&quot;);
          if (parts[0] == name)
            return decodeURIComponent(parts[1]);
        }
        return null;
      }</code></pre>

<p>Do you see the issue? Yes, it assumes that anything following the question mark is the query string. What it forgets about is the fragment part of the <span class="caps">URL</span>, the one following the <code>#</code> symbol. Any parameters in the fragment will be parsed as well. This wouldn&#8217;t normally be a big deal, but the fragment isn&#8217;t sent to the server! This means that no server-side firewall can see it, so it cannot stop attacks coming from this direction.</p>

<p>So here are some <span class="caps">URL</span>s that will trigger the <span class="caps">XSS</span> vulnerability here:</p>

<ul>
	<li>https://www.bugbountytraining.com/challenges/challenge-10.php#?message=%3Cimg%20src%3Ddumm%20onerror%3Dalert(%22xss%22)%3E</li>
	<li>https://www.bugbountytraining.com/challenges/challenge-10.php?message=#%3Cimg%20src%3Ddumm%20onerror%3Dalert(%22xss%22)%3E</li>
</ul>

<p>Of course, answers submitted by <span class="caps">BBN</span> users contained quite a few more variations. But what really surprised me was just how many people managed to solve this challenge without understanding how their solution worked. It seems that they attacked the Web Application Firewall blindly and just assumed that the firewall treated the <code>#</code> character specially for some reason.</p>

<p>Let&#8217;s close with an advise for all developers out there: don&#8217;t write your own <span class="caps">URL</span> parser. Even though <span class="caps">URL</span> parsing appears simple, there are many fall traps. If you need to do it, use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL"><span class="caps">URL</span> object</a>. If you need to parse query parameters, use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams">URLSearchParams object</a>. Even in non-browser environments, there are always well-tested <span class="caps">URL</span> parsers already available.</p>

<h4>The long route to exploiting a message handler</h4>

<p>The other challenge has no server side whatsoever, it&#8217;s merely a <a href="https://www.bugbountynotes.com/challenge?id=8">static web page</a>. And the issue with that page should also be fairly obvious: it listens to <code>message</code> events. When browsers added <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage">window.postMessage() <span class="caps">API</span></a> as a means of cross-domain communication, the idea was that any recipient would always check <code>event.origin</code> and reject unknown sources. But of course, many websites fail to validate the message sender at all or go for broken validation schemes. It is no different for this challenge.</p>

<p>Instead of validating the sender, this page validates the recipient: the recipient stated in the message has to match the page&#8217;s window name. Now the window name can be easily set by the attacker, e.g. by setting a name for the frame that this page is loaded into. The difficulty here is that the page will only consider certain recipients as “valid,” namely those where its own <a href="https://en.wikipedia.org/wiki/Rolling_hash#Cyclic_polynomial">Buzhash</a> variant results in <code>0x70617373</code> (or as a string: “pass”).</p>

<p>And that hash function is mean: no matter the input, the two bytes in the middle will always be <span class="caps">NUL</span> bytes! At least that&#8217;s the case as long as you constrain yourself to the <span class="caps">ASCII</span> character set. Once you start playing around with Unicode, the desired answer actually becomes possible. A bit of experimentation gives me <code>&quot;\x70\x61\u6161\0\0\0\0\u7373&quot;</code> as a valid recipient. But because <span class="caps">NUL</span> bytes in the <code>&lt;iframe name&gt;</code> attribute won&#8217;t work, I had to experiment a bit more to find a somewhat less obvious solution: <code>&quot;\x70\x10\x10\x10\x10\u6161\u6100\u7373&quot;</code>. Some <span class="caps">BBN</span> users solved this issue more elegantly: while <span class="caps">NUL</span> bytes in attributes don&#8217;t work, using them when setting <code>iframe.name</code> <i>property</i> works just fine. One submission also used Microsoft Z3 theorem prover instead of mere experimentation to find a valid recipient.</p>

<p>Once we managed to get the page to accept our message, what can we do then? Not a lot, we can make the page create a custom event for us. But there are no matching event listeners! That is, until you realize that <a href="https://api.jquery.com/ajaxSuccess/">jQuery&#8217;s ajaxSuccess callback</a> is actually a regular event handler. So we can trigger that callback.</p>

<p>But the callback merely sets element text, it doesn&#8217;t use <code>innerHTML</code> or its jQuery equivalent. So not vulnerable? No, setting text is unproblematic. But this code selecting the element is:</p>

<pre><code>$(data.selector)</code></pre>

<p>The <a href="https://api.jquery.com/jQuery/">jQuery constructor</a> is typically called with a selector. However, it supports a large number of different calling conventions. In particular, it (and many other jQuery methods) can be called with <span class="caps">HTML</span> code as parameter. This can lead to very non-obvious security issues as I pointed out <a href="/2015/08/30/why-you-probably-want-to-disable-jqueryparsehtml-even-though-you-don-t-call-it">a few years ago</a>. Here, passing some <span class="caps">HTML</span> code as “selector” will allow the attacker to run JavaScript code.</p>

<p>Here is my complete solution:</p>

<pre><code>&lt;script&gt;
  window.onload = function()
  {
    var frame = document.getElementById(&quot;frame&quot;);
    frame.contentWindow.postMessage({
      type: &quot;forward&quot;,
      event: &quot;ajaxSuccess&quot;,
      selector: &quot;&lt;img src=x onerror=alert(document.domain)&gt;&quot;,
      recipient: &quot;\x70\x10\x10\x10\x10\u6161\u6100\u7373&quot;
    }, &quot;*&quot;);
  };
&lt;/script&gt;
&lt;iframe id=&quot;frame&quot; src=&quot;https://www.bugbountytraining.com/challenges/challenge-8.html&quot; name=&quot;&amp;#x70;&amp;#x10;&amp;#x10;&amp;#x10;&amp;#x10;&amp;#x6161;&amp;#x6100;&amp;#x7373;&quot;&gt;&lt;/iframe&gt;</code></pre>

<p>This is only one way of demonstrating the issue of course, and some of the submissions from <span class="caps">BBN</span> users were more elegant than what I came up with myself.</p>