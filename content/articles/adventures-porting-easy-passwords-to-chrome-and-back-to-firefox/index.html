{
  "title": "Adventures porting Easy Passwords to Chrome and back to Firefox",
  "date": "2016-05-02 20:33:28",
  "description": "",
  "categories": [
    "mozilla",
    "pfp"
  ],
  "slug": "adventures-porting-easy-passwords-to-chrome-and-back-to-firefox"
}

<p>Easy Passwords is based on the Add-on <span class="caps">SDK</span> and runs in Firefox. However, people need access to their passwords in all kinds of environments, so I created an <a href="https://palant.github.io/easypasswords/online.html">online version</a> of the password generator. The next step was porting Easy Passwords to Chrome and Opera. And while at it, I wanted to see whether that port will work in Firefox via Web Extensions. After all, eventually the switch to Web Extensions will have to be done.</p>

<h4>Add-on <span class="caps">SDK</span> to Chrome <span class="caps">API</span>s</h4>

<p>The goal was using the same codebase for all variants of the extension. Most of the logic is contained in <span class="caps">HTML</span> files anyway, so it wouldn&#8217;t have to be changed. As to the remaining code, it should just work with some fairly minimal implementation of the <span class="caps">SDK</span> <span class="caps">API</span>s on top of the Chrome <span class="caps">API</span>s. Why not the other way round? Well, I consider the <span class="caps">API</span>s provided by the Add-on <span class="caps">SDK</span> much cleaner and easier to use.</p>

<p>It turned out that Easy Passwords used <a href="https://github.com/palant/easypasswords/tree/dfcad52aaf4984e671e9f41468133edcae207e89/chrome/lib/sdk">twelve <span class="caps">SDK</span> modules</a>, many of these could be implemented in a trivial way however. For example, the <a href="https://github.com/palant/easypasswords/blob/dfcad52aaf4984e671e9f41468133edcae207e89/chrome/lib/sdk/timers.js">timers module</a> merely exports functions that are defined anyway (unlike <span class="caps">SDK</span> extensions, Chrome extensions run in a window context).</p>

<p>There were a few conceptual differences however. For example, Chrome extensions don&#8217;t support modularization&nbsp;&mdash; all background scripts execute in a single shared scope of the background page. Luckily, <a href="http://browserify.org/">browserify</a> solves this problem nicely by compiling all the various modules into a single <code>background.js</code> script while giving each one its own scope.</p>

<p>The other issue is configuration: Chrome doesn&#8217;t generate settings UI automatically the way <a href="https://developer.mozilla.org/en-US/Add-ons/SDK/High-Level_APIs/simple-prefs">simple-prefs module does it</a>. No way around creating a <a href="https://github.com/palant/easypasswords/tree/master/chrome/data/options">special page for the two settings</a>. Getting automatic <span class="caps">SDK</span>-style localization of <span class="caps">HTML</span> pages on the other hand was only a matter of <a href="https://github.com/palant/easypasswords/blob/dfcad52aaf4984e671e9f41468133edcae207e89/chrome/data/i18n.js">a few lines</a> (Chrome makes it a bit more complicated by disallowing dashes in message names).</p>

<p>A tricky issue was unifying the way scripts are attached to <span class="caps">HTML</span> pages. With the Add-on <span class="caps">SDK</span> these are content scripts which are defined in the JavaScript code&nbsp;&mdash; otherwise they wouldn&#8217;t be able to communicate to the extension. In Chrome you use regular <code>&lt;script&gt;</code> tags however, the scripts get the necessary privileges automatically. In the end I had to go with <a href="https://github.com/palant/easypasswords/blob/dfcad52aaf4984e671e9f41468133edcae207e89/data/panel/panel.html#L12">conditional comments</a> interpreted by the build system, for the Chrome build these would become regular <span class="caps">HTML</span> code. This had the advantage that I could have additional scripts for Chrome only, in order to <a href="https://github.com/palant/easypasswords/blob/dfcad52aaf4984e671e9f41468133edcae207e89/chrome/data/compat.js">emulate the self variable</a> which is available to <span class="caps">SDK</span> content scripts.</p>

<p>Finally, communication turned out tricky as well. The Add-on <span class="caps">SDK</span> automatically connects a content script to whichever code is responsible for it. Whenever some code creates a panel it gets a <code>panel.port</code> property which can be used to communicate with that panel&nbsp;&mdash; and only with that panel. Chrome&#8217;s messaging on the other hand is all-to-all, the code is meant to figure out itself whether it is supposed to process a particular message or leave it for somebody else. And while Chrome also has a concept of communication ports, these can only be distinguished by their name&nbsp;&mdash; so my implementations of the <span class="caps">SDK</span> modules had to figure out which <span class="caps">SDK</span> object a new communication port was meant for by looking at its name. In the end I implemented a hack: since I had exactly one panel, exactly one page and exactly one page worker, I only set the type of the port as its name. Which object it should be associated with? Who cares, there is only one.</p>

<p>And that&#8217;s mostly it as far as issues go. Quite surprisingly, fancy JavaScript syntax is no longer an issue as of Chrome 49&nbsp;&mdash; let statements, <code>for..of</code> loops, rest parameters, destructuring assignments, all of this works. The only restrictions I noticed: node lists like <code>document.forms</code> cannot be used in <code>for..of</code> loops, and calling <code>Array.filter()</code> as opposed to <code>Array.prototype.filter.call()</code> isn&#8217;t supported (the former isn&#8217;t documented on <span class="caps">MDN</span> either, it seems to be non-standard). And a bunch of stuff which requires extra code with the Add-on <span class="caps">SDK</span> “just works”: pop-up size is automatically adjusted to content, switching tabs closes pop-up, tooltips and form validation messages work inside the pop-up like in every webpage.</p>

<p>The result was a <a href="https://chrome.google.com/webstore/detail/easy-passwords/hplhaekjfmjfnfdllkpjpeenlbclffgh">Chrome extension</a> that works just as well as the one for Firefox, with the exception of not being able to show the Easy Passwords icon in pop-up windows (sadly, I suspect that this limitation is intentional). It works in Opera as well and will be available in <a href="https://addons.opera.com/extensions/details/easy-passwords/">their add-on store</a> once it is reviewed.</p>

<h4>Chrome <span class="caps">API</span>s to Web Extensions?</h4>

<p>And what about running the Chrome port in Firefox now? Web Extensions are compatible to Chrome <span class="caps">API</span>s, so in theory it shouldn&#8217;t be a big deal. And in fact, after adding <a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json/applications">applications property</a> to <code>manifest.json</code> the extension could be installed in Firefox. However, after it replaced the version based on the Add-on <span class="caps">SDK</span> all the data was gone. This is <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1214790">bug 1214790</a> and I wonder what kind of solution the Mozilla developers can come up with.</p>

<p>It wasn&#8217;t really working either. Turned out, crypto functionality wasn&#8217;t working because the code was running in a context <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1258347">without access to Web Extensions <span class="caps">API</span>s</a>. Also, messages weren&#8217;t being received properly. After some testing I identified <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1269327">bug 1269327</a> as the culprit: proxied objects in messages were being dropped silently. Passing the message through <code>JSON.stringify()</code> and <code>JSON.parse()</code> before sending solved the issue, this would create a copy without any proxies.</p>

<p>And then there were visuals. One issue turned out to be a race condition which didn&#8217;t occur on Chrome, I guess that I made too many assumptions. Most of the others were due to <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1225633">bug 1225633</a> &mdash; somebody apparently considered it a good idea to apply a random set of <span class="caps">CSS</span> styles to unknown content. I filed <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1269334">bug 1269334</a> and <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1269336">bug 1269336</a> on the obvious bugs in these <span class="caps">CSS</span> styles, and overwrote some of the others in the extension. Finally, the nice pop-up sizing automation <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1215025">doesn&#8217;t work in Firefox</a>, so the size of the Easy Passwords pop-up is almost always wrong.</p>

<p>Interestingly, pretty much everything that Chrome does better than the Add-on <span class="caps">SDK</span> isn&#8217;t working with Web Extensions right now. It isn&#8217;t merely the pop-up sizing: <span class="caps">HTML</span> tooltips in pop-ups <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1269421">don&#8217;t show up</a>, and pop-ups <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1171746">aren&#8217;t being closed when switching tabs</a>. In addition, <code>tabs.query()</code> <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1269341">doesn&#8217;t allow searching extension pages</a> and submitting passwords <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1269350">produces bogus error messages</a>.</p>

<p>While most of these issues can be worked around easily, some are not. So I guess that it will take a while until I replace the <span class="caps">SDK</span>-based version of Easy Passwords by one based on Web Extensions.</p>