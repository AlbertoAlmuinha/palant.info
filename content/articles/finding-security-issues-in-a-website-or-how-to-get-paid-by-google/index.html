{"title": "Finding security issues in a website (or: How to get paid by Google)", "date": "2010-12-11 00:40:41", "description": "", "categories": ["security", "off-topic"], "slug": "finding-security-issues-in-a-website-or-how-to-get-paid-by-google"}

	<p>I received a payment over $2,500 from Google today. Now the conspiracy theorists among you can go off and rant in all forums that Adblock Plus is sponsored by Google and can no longer be trusted. For those of you who are still with me: the money came though Google&#8217;s <a href="http://www.google.com/corporate/rewardprogram.html">Vulnerability Reward Program</a>. Recently Google extended the scope of the program to web applications. I took up the challenge and sure enough, in a few hours I found four vulnerabilities in various corners of google.com.</p>

	<p>Now to make this clear: Google has a very capable security team with great response times (yes, Yahoo!, I am looking at you). They have proper security review processes in place and generally the security of their web applications is pretty good. If you go after their popular applications like search or Gmail or YouTube you will pretty soon discover that you need to invest more time than the bug bounty justifies. However, if you look around on google.com you will notice that it is home to many more web applications, most of which are rarely looked at. And guess what: finding vulnerabilities in these moldy corners is a lot easier. It probably won&#8217;t stay this way but right now Google seems to be overpaying for the vulnerabilities found.</p>

	<p>And that is the first lesson of web security: you cannot invest into securing one application but ignore others. If you know that one application is less secure, at least move it to a different domain where it cannot be used to compromise other applications (at least as <a href="http://en.wikipedia.org/wiki/Cross-site_scripting"><span class="caps">XSS</span></a> goes). Which still might turn out badly if a security vulnerability in that application allows an attacker to compromise the server.</p>

	<p>It so happened that each of the four vulnerabilities I found is different but each is typical in some way. I&#8217;ll describe them here as an example of what can go wrong in web development. Who knows, maybe it helps somebody to prevent making the same mistake.</p>

	<h4>The classic <span class="caps">XSS</span>: search field</h4>

	<p>Imagine for a moment that you opened up a website and want to get an idea about whether it was built with security in mind. How do you check that? Right, you go for the search field and type something like <code>test&lt;&gt;&quot;&#39;</code> into it. Check the source code of the result page, did the website turn your input into <code>test&amp;lt;&amp;gt;&amp;quot;&amp;#39;</code> or did it leave the &#8220;dangerous&#8221; characters unchanged? Chances are pretty good that it will be the latter and then your next input might be something like <code>&lt;script&gt;alert(&quot;I am evil&quot;)&lt;/script&gt;</code>. Yes, that webmaster is a <a href="http://en.wikipedia.org/wiki/Noob">noob</a> and <span class="caps">XSS</span>&#8217;ing the site is trivial.</p>

	<p>Now Google has been in the search business long enough and I would have imagined that they learned securing (and testing) search fields as the very first thing. So when I entered a search string into <a href="http://www.google.com/support/youtube/">YouTube Help</a> I didn&#8217;t really expect an <span class="caps">XSS</span> vulnerability, I was rather interested in seeing how the application works. But&nbsp;&mdash; the &#8220;Results in YouTube Help for &#8230;&#8221; message quoted my input unescaped. I don&#8217;t know how this passed security reviews, the only explanation I have: somehow this didn&#8217;t affect the English variant of the page, so maybe only the English variant was tested. Anyway, that issue was too obvious and someone managed to find it before me&nbsp;&mdash; this is the only report I didn&#8217;t get any money for.</p>

	<p>The usual advise to deal with <span class="caps">XSS</span> is to escape dangerous characters (&lt;, &gt;, &quot;, &#39;) every time when you insert user input into <span class="caps">HTML</span> code. However, doing this &#8220;manually&#8221; isn&#8217;t a good idea, it is much too easy to forget calling the escaping function  somewhere. Which is why some template frameworks (I would even say: every <em>good</em> template framework) allow to do the escaping automatically every time a variable is inserted into the template. Jinja2 for example allows you to <a href="http://jinja.pocoo.org/api/#autoescaping">turn on autoescaping by default</a> and then only <a href="http://jinja.pocoo.org/templates/#working-with-automatic-escaping">turn it off for some variables</a> which contain <span class="caps">HTML</span> code but have been verified as safe.</p>

	<h4>More complicated <span class="caps">XSS</span>: JavaScript attributes</h4>

	<p>The second vulnerability was also found in help search though in <a href="http://www.google.com/support/toolbar/">a different area</a>. When searching for <code>privacy&lt;&gt;&quot;&#39;</code> some links on the resulting page had an attribute like <code>onclick=&quot;RecordResultClick(&#39;privacy&amp;lt;&amp;gt;&amp;quot;&amp;#39;&#39;)&quot;</code>. At the first glance this looks correct. All dangerous characters have been escaped, so you cannot use your input to break out of the attribute or the JavaScript string. That is, until you remember that in <span class="caps">HTML</span> the entities are evaluated first to get the attribute value, and that attribute value is the JavaScript code that will run. In the case above the attribute value is <code>RecordResultClick(&#39;privacy&lt;&gt;&quot;&#39;&#39;)</code> so clicking the link will result in a syntax error&nbsp;&mdash; the string has two single quotation marks at the end. And with input like <code>&#39;+alert(/evil/)+&#39;</code> you can actually run your JavaScript code when the link is clicked.</p>

	<p>How does one protect against something like this? In this case you insert text into a JavaScript string that is inside an <span class="caps">HTML</span> attribute, so you first have to escape characters that are dangerous inside a JavaScript string (&#39;, backslash, newline&nbsp; need to be replaced by \&#39;, \\, \n respectively) and then additionally escape <span class="caps">HTML</span> entities. Which is complicated enough that people often get it wrong. So I would generally advise against generating JavaScript attributes dynamically, just don&#8217;t do it. Here is an alternative that is much easier to secure: <code>_query=&quot;privacy&amp;lt;&amp;gt;&amp;quot;&amp;#39;&quot; onclick=&quot;RecordResultClick(this.getAttribute(&#39;_query&#39;))&quot;</code>.</p>

	<h4><span class="caps">HTTP</span> Response Splitting</h4>

	<p><a href="http://en.wikipedia.org/wiki/HTTP_response_splitting"><span class="caps">HTTP</span> Response Splitting</a> is a very common and frequently underestimated issue. Max Kanat-Alexander <a href="http://avatraxiom.livejournal.com/104105.html">blogged about it recently</a> so I don&#8217;t need to explain it all over again. However, he failed to mention that this issue is most commonly found in scripts doing <span class="caps">HTTP</span> redirects. So when I noticed that a survey script on services.google.com was redirecting back to the survey page the first question was: where does it get the redirect target from?</p>

	<p>Turns out there were two <span class="caps">POST</span> parameters determining the redirect target: one was the actual <span class="caps">URL</span> and the other was an additional parameter that would be added to it. There was some code validating the <span class="caps">URL</span>, anything that used unusual characters or non-Google <span class="caps">URL</span>s would simply be ignored, so far so good (it did think that http://www.google.qwe.de is a Google <span class="caps">URL</span> however). But that additional parameter would be unescaped and then simply appended to the <span class="caps">URL</span>. So one could use <code>&quot;foo\nSet-Cookie: MyCookie=Hello, Google\n&quot;</code> as parameter value which would produce the output:</p>

<pre><code>HTTP/1.1 302 Found
Location: http://www.google.qwe.de/something/?foo
Set-Cookie: MyCookie=Hello, Google
</code></pre>

	<p>Yes, that would set a cookie on the Google domain. And no, I didn&#8217;t bother to check whether Google is vulnerable to <a href="http://en.wikipedia.org/wiki/Session_fixation">session fixation</a>. It is more interesting to turn this into <span class="caps">XSS</span> vulnerability but this wasn&#8217;t as trivial as in Max&#8217; example&nbsp;&mdash; this is a redirect after all and the browser would normally not display the content following the headers. It is possible to exploit persistent connections by specifying a too small <code>Content-Length</code> header, this tricks the browser into believing that the following content is the response to the next request on the same connection. But this option was prevented by some header validation mechanism on the server.</p>

	<p>The other option is to make the redirect fail, the browser will then display the <span class="caps">HTML</span> content following the headers. This is usually done by inserting a second <code>Location</code> header with an invalid value like <code>javascript:</code>. The browser will only consider the last header found and won&#8217;t redirect. But this was prevented by the same header validation mechanism which &#8220;helpfully&#8221; concatenated the values of all <code>Location</code> headers. And then I noticed one more feature of that header validation&nbsp;&mdash; if the header contained invalid characters (like a tab character) it would remove the entire header. Which was very convenient in this case because removing the Location header was exactly what I wanted. So the parameter value <code>&quot;foo\t\n\n&lt;script&gt;alert(&quot;Got you!&quot;)&lt;/script&gt;&quot;</code> produced the output:</p>

<pre><code>HTTP/1.1 302 Found
</code>
<code>&lt;script&gt;alert(&quot;Got you!&quot;)&lt;/script&gt;
</code></pre>

	<p>And that resulted in JavaScript executed in almost all browsers (with Internet Explorer being the only exception, it displayed a generic error page instead).</p>

	<p>So what can you do to prevent this from happening in your own web applications? It is actually quite easy, always send headers through a framework that won&#8217;t let you send more than one header at once (typically by checking for CR and LF characters, like <span class="caps">PHP</span> <code>header()</code> function starting with <span class="caps">PHP</span> 4.4.2/5.1.2). If your framework doesn&#8217;t do it, write your own helper function&nbsp;&mdash; it is easy. And I think that the best policy for potentially dangerous headers is not removing them but failing. Yes, really. Throw an exception and don&#8217;t show anything but a 500 Internal Server Error response, this way you cannot do anything wrong.</p>

	<h4>The hidden <span class="caps">XSS</span>: error response</h4>

	<p>People who are doing security reviews often concentrate on the main functionality of the application, things like error handling are typically less tested. Which is why somebody looking for security vulnerabilities will always try to make the application show an error to see whether this message is somehow exploitable. For example, I noticed that the <a href="https://www.google.com/analytics/siteopt/shortanswer">site optimizer tooltip script</a> will simply show a link if the <code>answer</code> parameter is missing. What did strike me about this link was the empty <code>hl</code> parameter. Could it be taking over the <code>hl</code> parameter from the query string? Turns out it did&nbsp;&mdash; and it forgot to escape dangerous characters while doing so. Yep, another <span class="caps">XSS</span> vulnerability.</p>

	<p>To state the obvious lesson here: unexpected conditions do happen, especially if your web application is being attacked. Very often a website is vulnerable simply because it quotes the requested <span class="caps">URL</span> in error messages. But you already know that you should always escape user input when it is inserted into <span class="caps">HTML</span>, and it is better to escape too much than too little. So I am concluding my already too long blog post.</p>