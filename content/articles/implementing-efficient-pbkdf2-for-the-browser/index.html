---
categories:
- security
- pfp
date: "2016-10-25 13:05:35"
description: ""
slug: implementing-efficient-pbkdf2-for-the-browser
title: Implementing efficient PBKDF2 for the browser
---

<p>As I <a href="/2016/04/20/security-considerations-for-password-generators">mentioned previously</a>, an efficient PBKDF2 implementation is absolutely essential for <a href="/2016/04/19/easy-passwords">Easy Passwords</a> in order to generate passwords securely. So when I looked into Microsoft Edge and discovered that it chose to implement WebCrypto <span class="caps">API</span> but <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/documentation/dev-guide/security/web-Cryptography-API/">not the PBKDF2 algorithm</a> this was quite a show-stopper. I still decided to investigate the alternatives, out of interest.</p>

<p>First of all I realized that Edge&#8217;s implementation of the WebCrypto <span class="caps">API</span> provides the <span class="caps">HMAC</span> algorithm which is a basic building block for PBKDF2. With PBKDF2 being a relatively simple algorithm on top of <span class="caps">HMAC</span>-SHA1, why not try to implement it this way? And so I implemented a fallback that would use <span class="caps">HMAC</span> if PBKDF2 wasn&#8217;t supported natively. It worked but there was a “tiny” drawback: generating a single password took 15 seconds on Edge, with Firefox not being significantly faster either.</p>

<p>I figured that the culprit was WebCrypto being asynchronous. This isn&#8217;t normally an issue, unless you have to do around 250 thousands <span class="caps">HMAC</span> operations&nbsp;&mdash; sending input data to another thread and receiving result for each single one of them. There is no way to call WebCrypto <span class="caps">API</span> in a synchronous fashion, not even from a web worker. Which means that using WebCrypto <span class="caps">API</span> in this way makes no sense here and pure JavaScript implementations would be faster.</p>

<p>So I went one step further. <span class="caps">HMAC</span> again is fairly simple, and the only non-trivial part here is SHA1. The <a href="https://github.com/srijs/rusha/">Rusha project</a> offers a very fast SHA1 implementation so I went with this one. And I realized that my 250 thousands <span class="caps">HMAC</span> operations were mostly hashing the same data: the first block of each hashing operation was derived from the secret key, always the same data. So I hacked Rusha so that it would allow me to pre-process this block and save the resulting state. <span class="caps">HMAC</span> would then restore the state and only hash the variable part of the input on top of it.</p>

<p>This implementation got the time down to 1.5 seconds on Edge&nbsp;&mdash; still not great but almost an acceptable delay for the user interface. And profiling made it obvious that the performance could still be improved: most time was being spent converting between big-endian and low-endian numbers. The issue is that SHA1 input is considered a sequence of big-endian numbers. With the calculation using low-endian numbers internally on almost every platform a fairly expensive conversion is necessary. And then the hashing result would be available as five low-endian numbers, yet for a proper byte representation of the SHA1 hash these need to be converted to big-endian again.</p>

<p>With PBKDF2 you are usually hashing the result of the previous hashing operation however. Converting that result from low-endian to big-endian only to perform the reverse conversion on the input is a complete waste. So I implemented a shortcut that allowed hashing the result of the previous hashing operation efficiently, without any conversion. While at it, I&#8217;ve thrown away most Rusha code since I was only using its high-performance core at that point anyway. And that change brought the password derivation time down to below 0.5 seconds on Edge. On Firefox the calculation even completes in 0.3 seconds which is very close to the 0.2 seconds needed by the native implementations on Firefox and Chrome.</p>

<p>Was it worth it? This implementation makes Edge a platform that can be realistically supported by Easy Passwords&nbsp;&mdash; but there are still lots of other issues to fix for that. But at least I updated the <a href="https://palant.github.io/easypasswords/online.html">online version of the password generator</a> which no longer relies on WebCrypto, meaning that it will work in any browser with typed arrays support&nbsp;&mdash; I even tested it in Internet Explorer 11 and it was still very fast.</p>

<p>I got into this one step after another so that I only thought about existing implementations when I was already done. Turns out, their performance isn&#8217;t too impressive, for whatever reason. I found four existing pure-JavaScript implementations of the PBKDF2-<span class="caps">HMAC</span>-SHA1 algorithm: <a href="https://github.com/bitwiseshiftleft/sjcl/"><span class="caps">SJCL</span></a>, <a href="https://github.com/digitalbazaar/forge/">forge</a>, <a href="https://github.com/crypto-browserify/pbkdf2">crypto-browserify</a> and <a href="https://code.google.com/archive/p/crypto-js/">crypto-js</a>. Out of those, crypto-js turned out to be so slow that I couldn&#8217;t even measure its performance. As <a href="http://dominictarr.github.io/crypto-bench/">this paper indicates</a>, its PBKDF2 implementation slows down massively as the number of iterations increases, this goes beyond linear.</p>

<p>As to the others, you can <a href="https://jsperf.com/pbkdf2-implementations-comparison">test them yourself if you like</a> (on browsers without native PBKDF2 support the first test will error out so you need to click the tests individually there). The following graph sums up my results:</p>

<p>{{< img "pbkdf2-performance.png" "Performance of PBKDF2 libraries in different browsers" >}}</p>

<p>The implementation I <a href="https://github.com/palant/easypasswords/blob/195b934e192a97c64e3998e337c33af552e12069/data/pbkdf2.js">added as fallback in Easy Passwords</a> now performs consistently well in all browsers, never needing more than twice the time of native implementations. The other pure-JavaScript implementations are at least factor three slower, always taking more than a second to derive a single password. For some reason they seem particularly slow in Edge, with crypto-browserify even taking around a minute for one operation.</p>

<p><b>Edit</b>: Shortly after writing all this I found <a href="https://github.com/vibornoff/asmcrypto.js">asmCrypto</a> that uses asm.js consistently. Guess what&nbsp;&mdash; its performance is on par with the native implementations and in Firefox it&#8217;s even significantly faster than that (around 0.1 seconds)! Thanks for reading up on my wasted effort.</p>