{"title": "Compiling C++ to JavaScript: Emscripten vs. Cheerp", "date": "2016-02-05 20:31:58", "description": "", "categories": ["emscripten"], "slug": "compiling-c-to-javascript-emscripten-vs-cheerp"}

	<p>Your JavaScript code is slow or needs too much memory? No problem, just rewrite it in C++ and compile back to JavaScript&nbsp;&mdash; you will get much better performance and the code will still run in any browser (or Node.js). Well, at least that&#8217;s what C++ to JavaScript compilers like Emscripten and Cheerp promise you. And often they can deliver, primarily thanks to heavy usage of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">typed arrays</a> which allow modern JavaScript engines to optimize the resulting code much better than more traditional JavaScript. Also, the code is already preoptimized, with the C++ compiler recognizing calculations yielding constant results as well as inlining short functions.</p>

	<p>I tried both Emscripten and Cheerp but the following isn&#8217;t exactly a fair comparison. For one, I spent much more time learning Emscripten than Cheerp, so I might have missed some Cheerp tweaks. Then again, I might have missed some Emscripten tweaks as well as I am by no means an expert in it. If you are still interested, enjoy the reading!</p>

	<h4>Does it work?</h4>

	<p>Sometimes. Of course, no amount of automated optimization will save you if you are using inefficient algorithms&nbsp;&mdash; these will be slow/memory intensive no matter what programming language you use. Also, my experience was that <span class="caps">STL</span> container classes produce too many memory allocations and copying operations to be fast (your mileage may vary). But there are plenty of areas where JavaScript isn&#8217;t the fastest, string processing being one example.</p>

	<p>I tried calculating the <a href="https://en.wikipedia.org/wiki/Fowler%25E2%2580%2593Noll%25E2%2580%2593Vo_hash_function#FNV-1a_hash"><span class="caps">FNV</span>-1a hash</a>, here is the corresponding C++ code:</p>

<pre>uint32_t hashCalc<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>int</span> index<span style='color:#808030; '>)</span>
<span style='color:#800080; '>{</span>
  <span style='color:#800000; font-weight:bold; '>const</span> <span style='color:#800000; font-weight:bold; '>char</span><span style='color:#808030; '>*</span> buffer <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>index <span style='color:#800080; '>?</span> buffer1 <span style='color:#800080; '>:</span> buffer2<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  uint32_t result <span style='color:#808030; '>=</span> <span style='color:#008c00; '>2166136261</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>for</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>int</span> i <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> i <span style='color:#808030; '>&lt;</span> <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span><span style='color:#603000; '>strlen</span><span style='color:#808030; '>(</span>buffer<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> i<span style='color:#808030; '>+</span><span style='color:#808030; '>+</span><span style='color:#808030; '>)</span>
    result <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>result <span style='color:#808030; '>^</span> buffer<span style='color:#808030; '>[</span>i<span style='color:#808030; '>]</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>*</span> <span style='color:#008c00; '>16777619</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>return</span> result<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>
Note that I am choosing from two strings here, depending on the parameter&nbsp;&mdash; otherwise the C++ compiler would happily optimize away the entire calculation since it is working on constant input only anyway. The same code in JavaScript would look like this:

<pre><span style='color:#800000; font-weight:bold; '>function</span> hashCalc<span style='color:#808030; '>(</span><span style='color:#797997; '>index</span><span style='color:#808030; '>)</span>
<span style='color:#800080; '>{</span>
  <span style='color:#800000; font-weight:bold; '>var</span> buffer <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#797997; '>index</span> <span style='color:#800080; '>?</span> buffer1 <span style='color:#800080; '>:</span> buffer2<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>var</span> result <span style='color:#808030; '>=</span> <span style='color:#008c00; '>2166136261</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>for</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>var</span> i <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span> i <span style='color:#808030; '>&lt;</span> buffer<span style='color:#808030; '>.</span><span style='color:#800000; font-weight:bold; '>length</span><span style='color:#800080; '>;</span> i<span style='color:#808030; '>++</span><span style='color:#808030; '>)</span>
    result <span style='color:#808030; '>=</span> <span style='color:#797997; '>Math</span><span style='color:#808030; '>.</span>imul<span style='color:#808030; '>(</span>result <span style='color:#808030; '>^</span> buffer<span style='color:#808030; '>.</span><span style='color:#800000; font-weight:bold; '>charCodeAt</span><span style='color:#808030; '>(</span>i<span style='color:#808030; '>)</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>16777619</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>return</span> result<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

	<p>Here Cheerp and Emscripten are roughly equal, with Emscripten being slightly faster but with the difference is almost too small to measure. Regular JavaScript code on the other hand takes around 2.5 times more time, the <code>charCodeAt()</code> calls being slow compared to accessing typed arrays.</p>

	<h4>Calling C++ from JavaScript</h4>

	<p>Of course, the C++ code above was only so fast because it already had the string in a typed array. What if it had to take a JavaScript string and convert it to a typed array first? That conversion would likely eat away the entire performance advantage. This is one important lesson I learned: if your compiled C++ code is being accessed from regular JavaScript then the transition better be extremely efficient or it will become the major factor slowing you down.</p>

	<p>Emscripten offers multiple ways of exposing an <span class="caps">API</span> to the JavaScript code. Out of these, <a href="http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html">Embind</a> is the most convenient. With a tiny bit of C++ interface description your C++ classes will automagically appear in JavaScript, and even smart pointers are handled transparently (you have to call <code>.delete()</code> in JavaScript code). This convenience comes at massive cost however: Embind generates the JavaScript bindings at runtime. In the first consequence, this increases the size of your compiled code significantly. All the Embind classes are compiled in, and they need enough information to create the JavaScript bindings. The bindings themselves are generated by calling <code>eval()</code> (problematic for Chrome extensions for example) and cost performance (20% on top of the direct call performance measured above).</p>

	<p>The other proposed solution is the <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/WebIDL-Binder.html">WebIDL binder</a> which will take an <a href="https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Write_an_API_reference/Information_contained_in_a_WebIDL_file">interface definition in WebIDL format</a> and compile it into C++ and JavaScript code that you can then add to your application. This approach should be more efficient but also makes compiling the application more complicated. I didn&#8217;t really try it however because I noticed that it maps <code>DOMString</code> to <code>std::string</code>, converting all JavaScript strings to <span class="caps">UTF</span>-8.</p>

	<p>You can always go with low-level calls however. Adding <code>EMSCRIPTEN_KEEPALIVE</code> to a function or method declaration will automatically export it, meaning that it can be called from JavaScript. You have to figure out the mangled name of the function yourself (easiest solution: <code>extern &quot;C&quot;</code> to disable mangling) and you have to keep any eye on calling conventions but it is very fast and efficient.</p>

	<p>As to Cheerp, there appears to be only one way to call from JavaScript into C++, by <a href="https://github.com/leaningtech/cheerp-meta/wiki/JavaScript-interoperability#the-jsexport-attribute">specifying the [[cheerp::jsexport]] attribute on a class</a>. It&#8217;s really that simple, you don&#8217;t need to do anything in addition and the generated bindings seem pretty efficient. The downside: the restrictions are currently severe. You cannot have a destructor or virtual methods, and static methods are dropped silently. Private methods on the other hand are happily exported. It seems that the only way to call a function without instantiating a class is declaring it as a non-static member of an exported class, not accessing <code>this</code> anywhere and calling it as <code>Class.prototype.myFunction</code>.</p>

	<h4>Memory model</h4>

	<p>C++ isn&#8217;t meant to run in a browser, it assumes some continuous address space that it accesses. Memory blocks are allocated, used, then freed. How is that mapped to JavaScript? The approaches used by Emscripten and Cheerp are radically different.</p>

	<p>Emscripten actually allocates a single continuous typed array to serve as the application&#8217;s memory. This makes it relatively easy to map C++ concepts to JavaScript: pointers represent an offset in the typed array, memory accesses are represented as accesses to this typed array. The downside is that Emscripten has to allocate a fairly large buffer (16 MB by default) from the start so that the application doesn&#8217;t run out of memory. The <a href="http://kripken.github.io/emscripten-site/docs/optimizing/Optimizing-Code.html#other-optimization-issues"><span class="caps">ALLOW</span>_MEMORY_GROWTH parameter</a> makes sure that the amount of available memory can increase but this is a slow operation (new typed array has to be allocated and the existing contents copied into it). But you get very low-level control over the memory allocations and powerful <a href="https://kripken.github.io/emscripten-site/docs/api_reference/trace.h.html">profiling functionality</a> for that.</p>

	<p>Cheerp on the other hand attempts to map C++ data structures to JavaScript data structures. So creating a C++ class instance will instantiate a JavaScript object. Class properties become properties of that JavaScript object, with pointers typically becoming references to a typed array. The obvious side-effect is that Cheerp is unable to reflect all C++ concepts properly, especially when it comes to pointers, e.g. the Cheerp-specific warning &#8220;Using values casted to unrelated types is undefined behaviour unless the destination type is the actual type of the value&#8221; comes up whenever pointers are casted. This function illustrates the problem nicely:</p>

<pre>uint16_t sum<span style='color:#808030; '>(</span>uint32_t dword<span style='color:#808030; '>)</span>
<span style='color:#800080; '>{</span>
  uint16_t<span style='color:#808030; '>*</span> ptr <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>reinterpret_cast</span><span style='color:#800080; '>&lt;</span>uint16_t<span style='color:#808030; '>*</span><span style='color:#800080; '>></span><span style='color:#808030; '>(</span><span style='color:#808030; '>&amp;</span>dword<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>return</span> ptr<span style='color:#808030; '>[</span><span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>+</span> ptr<span style='color:#808030; '>[</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

	<p>Compiling this with Emscripten and calling <code>sum(0x10002)</code> will correctly interpret the parameter as two 16-bit integers and return their sum (meaning 3). With Cheerp on the other hand <code>&amp;dword</code> creates an array with <code>dword</code> as its only element. <code>reinterpret_cast&lt;uint16_t*&gt;</code> then merely changes the way array elements are interpreted so when we say <code>ptr[0]</code> we get the first element of the array trimmed down to 16 bits. <code>ptr[1]</code> yields 0 on the other hand, there is no second element.</p>

	<p>So while Emscripten is often used to bring existing C/C++ code to the web, doing the same with Cheerp is very unlikely to succeed: the limitations require writing custom, Cheerp-optimized code. Also, the reliance on JavaScript objects means that as soon as classes or pointers are involved the performance of Cheerp drops drastically. This can be illustrated with the following code:</p>

<pre>uint32_t doSomething<span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>int</span> index<span style='color:#808030; '>)</span>
<span style='color:#800080; '>{</span>
  <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span><span style='color:#603000; '>string</span> str<span style='color:#808030; '>(</span>index <span style='color:#800080; '>?</span> buffer1 <span style='color:#800080; '>:</span> buffer2<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  str<span style='color:#808030; '>.</span>append<span style='color:#808030; '>(</span><span style='color:#800000; '>"</span><span style='color:#0000e6; '>something to add</span><span style='color:#800000; '>"</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  str<span style='color:#808030; '>.</span>erase<span style='color:#808030; '>(</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>12</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
  <span style='color:#800000; font-weight:bold; '>return</span> str<span style='color:#808030; '>.</span>length<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

	<p>Here Emscripten is four times faster than Cheerp. The equivalent JavaScript code is even ten times faster by the way: <code>std::string</code> will allocate a memory buffer on the heap and later reallocate it again, only to free it immediately. This doesn&#8217;t perform well, a stack-allocated string class would be able to achieve a much better performance here.</p>

	<h4>Code size</h4>

	<p>Something else worth mentioning is the code size. Cheerp seems to be the clear winner here, a minimal application compiles to a few hundred bytes. Emscripten on the other hand needs 150 kB even for the most trivial application, at least with the default parameters. Once you specify the <code>NO_BROWSER=1</code>, <code>NO_FILESYSTEM=1</code>, and <code>NODE_STDOUT_FLUSH_WORKAROUND=0</code> options things start to look better, and it once again gets better if you use the <code>SHELL_FILE</code> parameter to specify your own shell file. However, the code size will always be counted in tens of kilobytes.</p>

	<p>For larger applications the distance gets much smaller. Compiling my Emscripten codebase with Cheerp created a JavaScript file with almost the same size, and I&#8217;m not even sure that part of the code wasn&#8217;t optimized away. So it seems that for a large application the Emscripten output will be smaller than Cheerp&#8217;s.</p>

	<h4>Hey, what about asm.js?</h4>

	<p>Oh, right, Emscripten compiles to <a href="http://asmjs.org/">asm.js</a>. This means that JavaScript engines understanding asm.js (currently this refers only to Firefox but Google Chrome and Microsoft Edge want to add support soon) should be able to process it more efficiently. However, support for growing available memory has been <a href="https://discourse.wicg.io/t/request-for-comments-switching-resizing-heaps-in-asm-js/641/23">dropped from asm.js recently</a>. I don&#8217;t know about you but the applications I typically work on don&#8217;t know in advance how much memory is &#8220;enough.&#8221; I don&#8217;t really want to choose between crashing because the user loaded too much data and allocating way too much memory that merely sits there unused for almost everybody. So I use Emscripten with the <code>ASM_JS=2</code> parameter which makes it emit <code>&quot;almost asm&quot;</code> instead of <code>&quot;use asm&quot;</code>. And guess what? At least in my case it doesn&#8217;t seem to make a difference.</p>

	<h4>Bonus reading: what does the code look like?</h4>

	<p>The generated code can be tough to read, but it&#8217;s definitely simpler to understand than assembler. Here I want to show the output of a single code line:</p>

<pre><span style='color:#666616; '>std</span><span style='color:#800080; '>::</span><span style='color:#603000; '>string</span> str<span style='color:#808030; '>(</span>index <span style='color:#800080; '>?</span> buffer1 <span style='color:#800080; '>:</span> buffer2<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
</pre>

	<p>Here is Emscripten&#8217;s output, beautified and with variables and functions renamed for reading convenience:</p>

<pre><span style='color:#800000; font-weight:bold; '>var</span> savedStackPointer <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span>
    str <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
savedStackPointer <span style='color:#808030; '>=</span> stackPointer<span style='color:#800080; '>;</span>
stackPointer <span style='color:#808030; '>=</span> stackPointer <span style='color:#808030; '>+</span> <span style='color:#008c00; '>16</span> <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
str <span style='color:#808030; '>=</span> savedStackPointer<span style='color:#800080; '>;</span>
<span style='color:#797997; '>index</span> <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#797997; '>index</span> <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>!=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
basic_string__init<span style='color:#808030; '>(</span>str<span style='color:#808030; '>,</span> <span style='color:#797997; '>index</span> <span style='color:#800080; '>?</span> <span style='color:#008c00; '>896</span> <span style='color:#800080; '>:</span> <span style='color:#008c00; '>921</span><span style='color:#808030; '>,</span> <span style='color:#797997; '>index</span> <span style='color:#800080; '>?</span> <span style='color:#008c00; '>24</span> <span style='color:#800080; '>:</span> <span style='color:#008c00; '>30</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
<span style='color:#696969; '>// template &lt;class _CharT, class _Traits, class _Allocator></span>
<span style='color:#696969; '>// void</span>
<span style='color:#696969; '>// basic_string&lt;_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz) </span>
<span style='color:#800000; font-weight:bold; '>function</span> basic_string__init<span style='color:#808030; '>(</span>this_<span style='color:#808030; '>,</span> __s<span style='color:#808030; '>,</span> __sz<span style='color:#808030; '>)</span>
<span style='color:#800080; '>{</span>
    this_ <span style='color:#808030; '>=</span> this_ <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    __s <span style='color:#808030; '>=</span> __s <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    __sz <span style='color:#808030; '>=</span> __sz <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// pointer __p; </span>
    <span style='color:#800000; font-weight:bold; '>var</span> __p <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span>
        __cap <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// if (__sz > max_size()) this->__throw_length_error(); </span>
    <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>>>></span> <span style='color:#008c00; '>0</span> <span style='color:#808030; '>></span> <span style='color:#008c00; '>4294967279</span><span style='color:#808030; '>)</span> __throw_length_error<span style='color:#808030; '>(</span>this_<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// if (__sz &lt; __min_cap) </span>
    <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>>>></span> <span style='color:#008c00; '>0</span> <span style='color:#808030; '>&lt;</span> <span style='color:#008c00; '>11</span><span style='color:#808030; '>)</span>
    <span style='color:#800080; '>{</span>
        <span style='color:#696969; '>// __set_short_size(__sz);</span>
        HEAP8<span style='color:#808030; '>[</span>this_ <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> __sz <span style='color:#808030; '>&lt;&lt;</span> <span style='color:#008c00; '>1</span><span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// __p = __get_short_pointer();</span>
        this_ <span style='color:#808030; '>=</span> this_ <span style='color:#808030; '>+</span> <span style='color:#008c00; '>1</span> <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#800000; font-weight:bold; '>else</span>
    <span style='color:#800080; '>{</span>
        <span style='color:#696969; '>// size_type __cap = __recommend(__sz);</span>
        __cap <span style='color:#808030; '>=</span> __sz <span style='color:#808030; '>+</span> <span style='color:#008c00; '>16</span> <span style='color:#808030; '>&amp;</span> <span style='color:#808030; '>-</span><span style='color:#008c00; '>16</span><span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// __p = __alloc_traits::allocate(__alloc(), __cap+1);</span>
        __p <span style='color:#808030; '>=</span> bb<span style='color:#808030; '>(</span>__cap<span style='color:#808030; '>)</span> <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
        <span style='color:#696969; '>//__set_long_pointer(__p); </span>
        HEAP32<span style='color:#808030; '>[</span>this_ <span style='color:#808030; '>+</span> <span style='color:#008c00; '>8</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> __p<span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// __set_long_cap(__cap+1);</span>
        HEAP32<span style='color:#808030; '>[</span>this_ <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> __cap <span style='color:#808030; '>|</span> <span style='color:#008c00; '>1</span><span style='color:#800080; '>;</span>
        <span style='color:#696969; '>// __set_long_size(__sz);</span>
        HEAP32<span style='color:#808030; '>[</span>this_ <span style='color:#808030; '>+</span> <span style='color:#008c00; '>4</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> __sz<span style='color:#800080; '>;</span>
        this_ <span style='color:#808030; '>=</span> __p
    <span style='color:#800080; '>}</span>
    <span style='color:#696969; '>// traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);</span>
    rc<span style='color:#808030; '>(</span>this_ <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span> __s <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span> __sz <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>|</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// traits_type::assign(__p[__sz], value_type());</span>
    HEAP8<span style='color:#808030; '>[</span>this_ <span style='color:#808030; '>+</span> __sz <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>return</span>
<span style='color:#800080; '>}</span>
</pre>

	<p>No big surprises here, C++ code was mapped to JavaScript almost 1:1. String length parameter has been precalculated, a few calls have been inlined, and the <code>this_</code> parameter reused as a local variable. But the original code is relatively easy to recognize if you compare.</p>

	<p>And now the Cheerp code:</p>

<pre><span style='color:#800000; font-weight:bold; '>var</span> str <span style='color:#808030; '>=</span> aSlot <span style='color:#808030; '>=</span> <span style='color:#800080; '>{</span>
    i0<span style='color:#800080; '>:</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span>
    i1<span style='color:#800080; '>:</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span>
    a2<span style='color:#800080; '>:</span> nullArray
<span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>
basic_string__init<span style='color:#808030; '>(</span>str<span style='color:#808030; '>,</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#797997; '>index</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>!==</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>?</span> buffer1 <span style='color:#800080; '>:</span> buffer2<span style='color:#808030; '>)</span><span style='color:#808030; '>,</span>
                   <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#797997; '>index</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>!==</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>?</span> <span style='color:#008c00; '>0</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span> <span style='color:#800080; '>:</span> <span style='color:#008c00; '>0</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span>
                   <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#797997; '>index</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>!==</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>?</span> <span style='color:#008c00; '>24</span> <span style='color:#800080; '>:</span> <span style='color:#008c00; '>30</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
<span style='color:#696969; '>// template &lt;class _CharT, class _Traits, class _Allocator></span>
<span style='color:#696969; '>// void</span>
<span style='color:#696969; '>// basic_string&lt;_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)</span>
<span style='color:#800000; font-weight:bold; '>function</span> basic_string__init<span style='color:#808030; '>(</span>this_<span style='color:#808030; '>,</span> __s<span style='color:#808030; '>,</span> __offset<span style='color:#808030; '>,</span> __sz<span style='color:#808030; '>)</span>
<span style='color:#800080; '>{</span>
    <span style='color:#800000; font-weight:bold; '>var</span> label <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// if (__sz > max_size()) this->__throw_length_error();</span>
    <span style='color:#696969; '>// size_type __cap = __recommend(__sz);</span>
    <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>>>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>&lt;</span> <span style='color:#008c00; '>11</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span>
        <span style='color:#800000; font-weight:bold; '>var</span> a <span style='color:#808030; '>=</span> <span style='color:#008c00; '>11</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>else</span>
        <span style='color:#800000; font-weight:bold; '>var</span> a <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span><span style='color:#008c00; '>16</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>&amp;</span> <span style='color:#808030; '>-</span><span style='color:#008c00; '>16</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// __p = __alloc_traits::allocate(__alloc(), __cap+1);</span>
    <span style='color:#800000; font-weight:bold; '>var</span> __p <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>new</span> Uint8Array<span style='color:#808030; '>(</span>a <span style='color:#808030; '>/</span> <span style='color:#008c00; '>1</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// __set_long_pointer(__p);</span>
    this_<span style='color:#808030; '>.</span>a2 <span style='color:#808030; '>=</span> __p<span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// __set_long_cap(__cap+1); </span>
    this_<span style='color:#808030; '>.</span>i0 <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>a <span style='color:#808030; '>|</span> <span style='color:#008c00; '>1</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// __set_long_size(__sz);</span>
    this_<span style='color:#808030; '>.</span>i1 <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
    <span style='color:#696969; '>// traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);</span>
    <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>!</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span>
    <span style='color:#800080; '>{</span>
        <span style='color:#800000; font-weight:bold; '>var</span> a <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
        <span style='color:#800000; font-weight:bold; '>while</span> <span style='color:#808030; '>(</span><span style='color:#008c00; '>1</span><span style='color:#808030; '>)</span>
        <span style='color:#800080; '>{</span>
            __p<span style='color:#808030; '>[</span><span style='color:#808030; '>(</span><span style='color:#008c00; '>0</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span>a <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>__s<span style='color:#808030; '>[</span><span style='color:#808030; '>(</span>__offset <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span>a <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>&amp;</span> <span style='color:#008c00; '>255</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>&amp;</span> <span style='color:#008c00; '>255</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
            <span style='color:#800000; font-weight:bold; '>var</span> a <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>a <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span><span style='color:#008c00; '>1</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
            <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>(</span><span style='color:#808030; '>(</span>a <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>=</span> <span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span>
                <span style='color:#800000; font-weight:bold; '>break</span><span style='color:#800080; '>;</span>
        <span style='color:#800080; '>}</span>
    <span style='color:#800080; '>}</span>
    <span style='color:#696969; '>// traits_type::assign(__p[__sz], value_type());</span>
    __p<span style='color:#808030; '>[</span><span style='color:#808030; '>(</span><span style='color:#008c00; '>0</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span>__sz <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>></span><span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#800080; '>;</span>
    <span style='color:#800000; font-weight:bold; '>return</span><span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>

	<p>One thing that got me confused at first was the additional <code>__offset</code> parameter (at least that&#8217;s how I named it). Eventually I realized that each pointer is represented as two variables for Cheerp: one holding the reference to a typed array and another denoting the offset inside that array. So the initial <code>__s</code> parameter got converted into two parameters in the generated code. This conversion of pointers into two variables must have happened after the optimization step, otherwise the optimizer would have recognized that <code>(((index &gt;&gt; 0) !== 0) ? 0 &gt;&gt; 0 : 0 &gt;&gt; 0) &gt;&gt; 0</code> is always zero and removed the pointless parameter from the function altogether.</p>

	<p>The major difference however is the <code>this_</code> parameter: it&#8217;s a real JavaScript object with the fields <code>i0</code> and <code>i1</code> representing string capacity and length respectively, and field <code>a2</code> a reference to the typed array holding the data. While I didn&#8217;t measure the impact of it, I have a strong suspicion that this approach of creating many small JavaScript objects is wasting lots of memory.</p>

	<p>There are some minor differences worth noting: the branch allocating the string buffer on the stack is missing, Cheerp removed it from the include file (it makes little sense without a stack concept). Also, variable <code>a</code> is pointlessly declared four times throughout the function. It&#8217;s a common tendency with Cheerp-generated code but apparently it gets away with this despite declaring <code>&quot;use strict&quot;</code>.</p>